RMI全称是Remote Method Invocation－远程方法调用，Java RMI在JDK1.1中实现的，
其威力就体现在它强大的开发分布式网络应用的能力上，是纯Java的网络分布式应用系统的核心解决方案之一。
其实它可以被看作是RPC的Java版本。但是传统RPC并不能很好地应用于分布式对象系统。
而Java RMI 则支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。

Java RMI不是什么新技术（在Java1.1的时代都有了），但却是是非常重要的底层技术。
大名鼎鼎的EJB都是建立在rmi基础之上的，现在还有一些开源的远程调用组件，其底层技术也是rmi。

在大力鼓吹Web Service、SOA的时代，是不是每个应用都应该选用笨拙的Web Service组件来实现，通过对比测试后，RMI是最简单的，在一些小的应用中是最合适的。


RMI目前使用Java远程消息交换协议JRMP（Java Remote Messaging Protocol）进行通信。
由于JRMP是专为Java对象制定的，Java RMI具有Java的"Write Once,Run Anywhere"的优点，是分布式应用系统的百分之百纯Java解决方案。
用Java RMI开发的应用系统可以部署在任何支持JRE（Java Run Environment Java，运行环境）的平台上。
但由于JRMP是专为Java对象制定的，因此，RMI对于用非Java语言开发的应用系统的支持不足。不能与用非Java语言书写的对象进行通信。

RMI可利用标准Java本机方法接口JNI与现有的和原有的系统相连接。RMI还可利用标准JDBC包与现有的关系数据库连接。
RMI/JNI和RMI/JDBC相结合，可帮助您利用RMI与目前使用非Java语言的现有服务器进行通信，而且在您需要时可扩展Java在这些服务器上的使用。
RMI可帮助您在扩展使用时充分利用Java的强大功能。


从上面的过程来看，RMI对服务器的IP地址和端口依赖很紧密，但是在开发的时候不知道将来的服务器IP和端口如何，但是客户端程序依赖这个IP和端口。
这也是RMI的局限性之一。这个问题有两种解决途径：一是通过DNS来解决，二是通过封装将IP暴露到程序代码之外。
RMI的局限性之二是RMI是Java语言的远程调用，两端的程序语言必须是Java实现，
对于不同语言间的通讯可以考虑用Web Service或者公用对象请求代理体系（CORBA）来实现。


RMI 一般有两个端口，一个是服务端口（默认是 1099），一个是数据端口（默认随机生成）
在项目中使用rmi,发布到linux,unix，由于开了防火墙。需要配置防火墙端口。刚开始配置了一个固定端口，死都连接不通，
后来同netstat -antup |grep pid 查看进程监听的端口，，发现原来rmi有2个端口一个是固定的。一个是随机的。

RMI之所以使用的范围受限制主要有两方面原因，其一：必须要是java，平台的异构性受到限制；
其二：穿越防火墙不方便。这里主要谈谈RMI如何通过固定分配端口来穿越防火墙。
 RMI穿越防火墙不方便主要是因为除了RMI服务注册的端口(默认1099)外，
 与RMI的通讯还需要另外的端口来传送数据，而另外的端口是随机分配的，所以要想RMI的客户能通过防火墙来与RMI服务通讯，
 则需要能让随机分配的端口固定下来，具体做法如下：